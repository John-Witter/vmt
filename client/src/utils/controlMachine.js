import React from 'react';
import PropTypes from 'prop-types';
import { createMachine, assign } from 'xstate';
import { useMachine } from '@xstate/react';
import { createMongoId, socket } from 'utils';
import { Room } from 'Model';

const STRATEGY = {
  INDEPENDENT: 'independent',
  DEFAULT: 'default',
};

export const controlStates = {
  NONE: 'NONE',
  ME: 'ME',
  OTHER: 'OTHER',
  REQUESTED: 'REQUESTED',
  CANCELLED_REQUEST: 'CANCELLED_REQUEST',
  SWITCHING_TABS: 'SWITCHING_TABS',
};

export const controlEvents = {
  CLICK: 'CLICK',
  MSG_RECEIVED: 'MSG_RECEIVED',
  MSG_TOOK_CONTROL: 'MSG_TOOK_CONTROL',
  MSG_RELEASED_CONTROL: 'MSG_RELEASED_CONTROL',
  RESET: 'RESET',
  SWITCH_TAB: 'SWITCH_TAB',
};

export const buttonConfigs = {
  [controlStates.NONE]: {
    text: 'Take Control',
    disabled: false,
  },
  [controlStates.ME]: {
    text: 'Release Control',
    disabled: false,
  },
  [controlStates.OTHER]: {
    text: 'Request Control',
    disabled: false,
  },
  [controlStates.REQUESTED]: {
    text: 'Cancel Request',
    disabled: false,
  },
  [controlStates.CANCELLED_REQUEST]: {
    text: 'Request Control',
    disabled: true,
  },
};
/** ***************************************************************
 * actions taken when certain events occur
 ***************************************************************** */
const iTakeControl = (context, event) => {
  const isIndependent = context.strategy === STRATEGY.INDEPENDENT;
  const message = {
    _id: createMongoId(),
    user: { _id: context.userId, username: 'VMTBot' },
    room: context.roomId,
    tab: context.currentTabId,
    text: isIndependent
      ? `${context.username} took control on tab #${event.tabNum}`
      : `${context.username} took control`,
    messageType: 'TOOK_CONTROL',
    autogenerated: true,
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'TAKE_CONTROL',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const iReleaseControl = (context, event) => {
  const isIndependent = context.strategy === STRATEGY.INDEPENDENT;
  const message = {
    _id: createMongoId(),
    user: { _id: context.userId, username: 'VMTBot' },
    room: context.roomId,
    tab: context.currentTabId,
    text: isIndependent
      ? `${context.username} released control on tab #${event.tabNum}`
      : `${context.username} released control`,
    autogenerated: true,
    messageType: 'RELEASED_CONTROL',
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'RELEASE_CONTROL',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const iTimeOut = (context) => {
  // @TODO: At this point, we cannot provide a tab number because that's not kept in the control machine context
  // Note that iTimeOut is called by the control machine, not via a sendEvent, so the 'event' parameter is always empty
  const message = {
    _id: createMongoId(),
    user: { _id: context.userId, username: 'VMTBot' },
    room: context.roomId,
    tab: context.currentTabId,
    text: `${context.username} control was released by system`,
    autogenerated: true,
    messageType: 'RELEASED_CONTROL',
    color: '#f26247',
    timestamp: Date.now(),
  };
  socket.emit('RELEASE_CONTROL', message);
};

const iRequestControl = (context, event) => {
  const isIndependent = context.strategy === STRATEGY.INDEPENDENT;

  const message = {
    _id: createMongoId(),
    text: isIndependent
      ? `Can I take control on tab #${event.tabNum}?`
      : 'Can I take control?',
    messageType: 'TEXT',
    user: { _id: context.userId, username: context.username },
    room: context.roomId,
    tab: context.currentTabId,
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'SEND_MESSAGE',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const otherTakesControl = () => {
  // nothing to do
};

const otherReleasesControl = () => {
  // nothing for me to do
};

const iCancelRequest = (context, event) => {
  const isIndependent = context.strategy === STRATEGY.INDEPENDENT;

  const message = {
    _id: createMongoId(),
    text: isIndependent
      ? `Nevermind. I don't want control on tab #${event.tabNum}`
      : "Nevermind. I don't want control.",
    messageType: 'TEXT',
    user: { _id: context.userId, username: context.username },
    room: context.roomId,
    tab: context.currentTabId,
    color: event.myColor || '#f26247',
    timestamp: Date.now(),
  };
  socket.emit(
    'SEND_MESSAGE',
    message,
    typeof event.callback === 'function' ? () => event.callback(message) : null
  );
};

const defaultControlMachineSpec = (initial, context) => {
  return [
    {
      predictableActionArguments: true,
      id: 'control',
      initial,
      context: { ...context, strategy: STRATEGY.DEFAULT },
      on: {
        [controlEvents.MSG_RELEASED_CONTROL]: {
          target: controlStates.NONE,
          actions: 'otherReleasesControl',
        },
        [controlEvents.MSG_TOOK_CONTROL]: {
          target: controlStates.OTHER,
          actions: 'otherTakesControl',
        },
        [controlEvents.SWITCH_TAB]: { actions: 'switchingTabs' },
      },
      states: {
        [controlStates.NONE]: {
          entry: 'controlledByNone',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.ME,
              actions: 'iTakeControl',
            },
          },
        },
        [controlStates.ME]: {
          entry: 'controlledByMe',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.NONE,
              actions: 'iReleaseControl',
            },
            [controlEvents.RESET]: controlStates.ME,
          },
          after: {
            60000: { target: controlStates.NONE, actions: 'iTimeOut' },
          },
        },
        [controlStates.OTHER]: {
          entry: 'controlledByOther',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.REQUESTED,
              actions: 'iRequestControl',
            },
          },
        },
        [controlStates.REQUESTED]: {
          entry: 'controlRequested',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.CANCELLED_REQUEST,
              actions: 'iCancelRequest',
            },
          },
          after: {
            60000: controlStates.OTHER,
          },
        },
        [controlStates.CANCELLED_REQUEST]: {
          entry: 'cancelledRequest',
          after: {
            60000: controlStates.OTHER,
          },
        },
      },
    },
    {
      actions: {
        iTakeControl,
        otherTakesControl,
        iReleaseControl,
        iTimeOut,
        iRequestControl,
        otherReleasesControl,
        iCancelRequest,
        controlledByMe: assign({
          controlledBy: (c) => c.userId,
          buttonConfig: buttonConfigs[controlStates.ME],
        }),
        controlledByOther: assign({
          controlledBy: (_, event) => event.id,
          buttonConfig: buttonConfigs[controlStates.OTHER],
        }),
        controlledByNone: assign({
          controlledBy: null,
          buttonConfig: buttonConfigs[controlStates.NONE],
        }),
        controlRequested: assign({
          buttonConfig: buttonConfigs[controlStates.REQUESTED],
        }),
        cancelledRequest: assign({
          buttonConfig: buttonConfigs[controlStates.CANCELLED_REQUEST],
        }),
        switchingTabs: assign({
          currentTabId: (_, event) => event.tab,
        }),
      },
    },
  ];
};

const independentTabControlMachineSpec = (initial, context) => {
  return [
    {
      predictableActionArguments: true,
      id: 'control',
      initial,
      context: { ...context, strategy: STRATEGY.INDEPENDENT },
      on: {
        [controlEvents.MSG_RELEASED_CONTROL]: [
          {
            cond: (c, event) => c.currentTabId === event.tab,
            target: controlStates.NONE,
            actions: ['otherReleasesControl', 'storeNull'],
          },
          {
            cond: (c, event) => c.currentTabId !== event.tab,
            actions: 'storeNull',
          },
        ],
        [controlEvents.MSG_TOOK_CONTROL]: [
          {
            cond: (c, event) => c.currentTabId === event.tab,
            target: controlStates.OTHER,
            actions: ['otherTakesControl', 'storeController'],
          },
          {
            cond: (c, event) => c.currentTabId !== event.tab,
            actions: 'storeController',
          },
        ],
      },
      states: {
        [controlStates.NONE]: {
          entry: 'controlledByNone',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.ME,
              actions: 'iTakeControl',
            },
            [controlEvents.SWITCH_TAB]: controlStates.SWITCHING_TABS,
          },
        },
        [controlStates.ME]: {
          entry: 'controlledByMe',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.NONE,
              actions: 'iReleaseControl',
            },
            [controlEvents.RESET]: controlStates.ME,
            [controlEvents.SWITCH_TAB]: {
              target: controlStates.SWITCHING_TABS,
              actions: 'iReleaseControl', // @TODO: potentially different msg if released due to switching
            },
          },
          after: {
            60000: { target: controlStates.NONE, actions: 'iTimeOut' },
          },
        },
        [controlStates.OTHER]: {
          entry: 'controlledByOther',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.REQUESTED,
              actions: 'iRequestControl',
            },
            [controlEvents.SWITCH_TAB]: controlStates.SWITCHING_TABS,
          },
        },
        [controlStates.REQUESTED]: {
          entry: 'controlRequested',
          on: {
            [controlEvents.CLICK]: {
              target: controlStates.CANCELLED_REQUEST,
              actions: 'iCancelRequest',
            },
            [controlEvents.SWITCH_TAB]: {
              target: controlStates.SWITCHING_TABS,
              actions: ['iCancelRequest', 'setRestrictFlag'], // @TODO: Potentially different message when cancel via switching tabs
            },
          },
          after: {
            60000: controlStates.OTHER,
          },
        },
        [controlStates.CANCELLED_REQUEST]: {
          entry: 'cancelledRequest',
          on: {
            [controlEvents.SWITCH_TAB]: {
              target: controlStates.SWITCHING_TABS,
              actions: 'setRestrictFlag', // @TODO: Potentially different message when cancel via switching tabs
            },
          },
          after: {
            60000: controlStates.OTHER,
          },
        },
        [controlStates.SWITCHING_TABS]: {
          entry: 'switchingTabs',
          always: [
            {
              cond: (c) =>
                !!c.controllers[c.currentTabId] &&
                c.restrictFlags[c.currentTabId],
              target: controlStates.CANCELLED_REQUEST,
            },
            {
              cond: (c) =>
                !!c.controllers[c.currentTabId] &&
                !c.restrictFlags[c.currentTabId],
              target: controlStates.OTHER,
            },
            {
              cond: (c) => !c.controllers[c.currentTabId],
              target: controlStates.NONE,
            },
          ],
        },
      },
    },
    {
      actions: {
        iTakeControl,
        otherTakesControl,
        iReleaseControl,
        iTimeOut,
        iRequestControl,
        otherReleasesControl,
        iCancelRequest,
        storeNull: assign({
          controllers: (c, event) => ({
            ...c.controllers,
            [event.tab]: null,
          }),
        }),
        storeController: assign({
          controllers: (c, event) => ({
            ...c.controllers,
            [event.tab]: event.id,
          }),
        }),
        setRestrictFlag: assign({
          restrictFlags: (c) => ({
            ...c.restrictFlags,
            [c.currentTabId]: true,
          }),
        }),
        switchingTabs: assign({
          currentTabId: (_, event) => event.tab,
        }),
        controlledByMe: assign({
          controlledBy: (c) => c.userId,
          controllers: (c) => ({
            ...c.controllers,
            [c.currentTabId]: null,
          }),
          buttonConfig: buttonConfigs[controlStates.ME],
        }),
        controlledByOther: assign({
          controlledBy: (c) => c.controllers[c.currentTabId],
          buttonConfig: buttonConfigs[controlStates.OTHER],
        }),
        controlledByNone: assign({
          controlledBy: null,
          controllers: (c) => ({
            ...c.controllers,
            [c.currentTabId]: null,
          }),
          buttonConfig: buttonConfigs[controlStates.NONE],
        }),
        controlRequested: assign({
          buttonConfig: buttonConfigs[controlStates.REQUESTED],
        }),
        cancelledRequest: assign({
          buttonConfig: buttonConfigs[controlStates.CANCELLED_REQUEST],
          restrictFlags: (c) => ({
            ...c.restrictFlags,
            [c.currentTabId]: false,
          }),
        }),
      },
    },
  ];
};

/**
 * @returns {Array} [state, send] - 'state' is the current state object. 'send' is a function that receives a control action.
 * Keys parts of state:
 *  - state.meta -- an object that can be handed to controlButton
 *  - state.value -- a string representing the state. Right now, matches with the legacy inControl, so can be used there.
 *
 * Ideally, state would also embed the 'controlledBy' state variable now maintained by Workspace (from the DB). This would allow
 * us to keep the control state in one place (the controlMachine).
 *
 */
export function useControlMachine(context, spec) {
  // Figure out the initial state
  let initial = controlStates.NONE;
  if (!context.controlledBy) initial = controlStates.NONE;
  else if (context.controlledBy === context.userId) initial = controlStates.ME;
  else initial = controlStates.OTHER;

  // use of the Ref prevents the re-creation of the machine, which causes a warning
  const controlMachineRef = React.useRef(null);
  if (!controlMachineRef.current)
    controlMachineRef.current = createMachine(...spec(initial, context));

  const [state, send] = useMachine(controlMachineRef.current);

  return [
    {
      ...state,
      inControl: state.value,
      buttonConfig: state.context.buttonConfig,
      controlledBy: state.context.controlledBy,
      currentTabId: state.context.currentTabId,
      controllers: state.context.controllers,
    },
    send,
  ];
}

export function withControlMachine(Component) {
  const ControlMachine = (props) => {
    const { populatedRoom, user } = props;
    const [state, send] = useControlMachine(
      {
        userId: user._id,
        roomId: populatedRoom._id,
        username: user.username,
        controlledBy: populatedRoom.tabs[0].controlledBy,
        currentTabId: populatedRoom.tabs[0]._id,
        controllers: populatedRoom.tabs.reduce(
          (acc, tab) => ({ ...acc, [tab._id]: tab.controlledBy }),
          {}
        ),
        restrictFlags: {},
      },
      Room.getRoomSetting(populatedRoom, Room.TAB_BASED_CONTROL)
        ? independentTabControlMachineSpec
        : defaultControlMachineSpec
    );
    return (
      <Component controlState={state} sendControlEvent={send} {...props} />
    );
  };

  ControlMachine.propTypes = {
    populatedRoom: PropTypes.shape({
      _id: PropTypes.string,
      controlledBy: PropTypes.string,
      tabs: PropTypes.arrayOf(
        PropTypes.shape({
          _id: PropTypes.string,
          controlledBy: PropTypes.string,
        })
      ),
      settings: PropTypes.shape({ independentTabControl: PropTypes.bool }),
    }).isRequired,
    user: PropTypes.shape({ _id: PropTypes.string, username: PropTypes.string })
      .isRequired,
  };

  return ControlMachine;
}
