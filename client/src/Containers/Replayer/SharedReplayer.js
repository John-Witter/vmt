import React, { Component, Fragment } from 'react';
import WorkspaceLayout from '../../Layout/Workspace/Workspace';

import ReplayerControls from './ReplayerControls';
import DesmosReplayer from './DesmosReplayer';
import GgbReplayer from './GgbReplayer';
import ChatReplayer from './ChatReplayer';
import Clock from './Clock';
import Slider from './Slider';
import Settings from './Settings';

import CurrentMembers from '../../Components/CurrentMembers/CurrentMembers';
import Loading from '../../Components/Loading/Loading';
import Tabs from '../Workspace/Tabs';
import Tools from '../Workspace/Tools/Tools';
// import throttle from "lodash/throttle";
import moment from 'moment';

const MAX_WAIT = 10000; // 10 seconds
const BREAK_DURATION = 2000;
const PLAYBACK_FIDELITY = 100;
const INITIAL_STATE = {
  playing: false,
  playbackSpeed: 1,
  logIndex: 0,
  timeElapsed: 0, // MS
  absTimeElapsed: 0,
  changingIndex: false,
  currentMembers: [],
  allTabsLoaded: false,
  startTime: '',
  loading: true,
  currentTab: 0,
  multipleTabTypes: false,
  isFullscreen: false,
  showControls: true,
};
class SharedReplayer extends Component {
  state = INITIAL_STATE;
  updatedLog = [];
  tabsLoaded = 0;
  endTime = 0;

  componentDidMount() {
    // @TODO We should never populate the tabs events before getting here
    // we dont need them for the regular room activity only for playback
    if (!this.props.encompass) {
      this.props.populateRoom(this.props.match.params.room_id, {
        events: true,
      });
    } else {
      this.buildLog();

      // listen for messages from encompasss
      window.addEventListener('message', this.onEncMessage);
    }
  }

  componentWillUnmount() {
    window.removeEventListener('message', this.onEncMessage);
    if (this.interval) {
      clearInterval(this.interval);
    }
  }

  buildLog = () => {
    this.log = this.props.room.log;
    this.updatedLog = [];
    this.tabsLoaded = 0;

    this.endTime = moment
      .unix(this.log[this.log.length - 1].timestamp / 1000)
      .format('MM/DD/YYYY h:mm:ss A');
    /** @todo refacotring to a for loop */
    this.relativeDuration = this.log.reduce((acc, cur, idx, src) => {
      // Copy currentEvent
      let event = { ...cur };
      // Add the relative Time
      event.relTime = acc;
      // ADD A TAB FOR EVENTS THAT DONT ALREADY HAVE THEM TO MAKE SKIPPING AROUND EASIER
      if (!event.tab) {
        // when would we ever have an event without a tab ID ? // is this so it works with old data before we had tabs?
        if (!src[idx - 1]) {
          //IF this is the first event give it the starting tab
          event.tab = this.props.room.tabs[0]._id;
        } else {
          event.tab = this.updatedLog[this.updatedLog.length - 1].tab; //Else give it the same tabId as the event before
        }
      }
      this.updatedLog.push(event);
      // calculate the next time
      if (src[idx + 1]) {
        let diff = src[idx + 1].timestamp - cur.timestamp;
        if (diff < MAX_WAIT) {
          return (acc += diff);
        } else {
          this.updatedLog.push({
            synthetic: true,
            message: `No activity ... skipping ahead to ${moment
              .unix(src[idx + 1].timestamp / 1000)
              .format('MM/DD/YYYY h:mm:ss A')}`,
            relTime: (acc += BREAK_DURATION),
            tab: this.updatedLog[this.updatedLog.length - 1].tab,
          });
          return (acc += BREAK_DURATION);
        }
      } else return acc;
    }, 0);
    const updatedMembers = [];
    if (this.log[0].autogenerated) {
      // DONT NEED TO CHECK IF THEYRE ENTERING OR EXITING, BECAUSE ITS THE FIRST EVENT THEY MUST
      // BE ENTERING
      updatedMembers.push({ user: this.log[0].user });
    }
    this.setState({
      startTime: moment
        .unix(this.log[0].timestamp / 1000)
        .format('MM/DD/YYYY h:mm:ss A'),
      currentMembers: updatedMembers,
    });
    this.setState({ loading: false }, () => {
      if (this.props.encompass) {
        // let encompass know the room has finished loading
        // also update window with replayer state/duration
        this.props.updateEnc(
          'VMT_ON_REPLAYER_LOAD',
          this.state,
          this.relativeDuration
        );
      }
    });
  };

  componentDidUpdate(prevProps, prevState) {
    // Once we've fetched the room, build a log of all the events by combining all of the events from each tab
    // in chornological order
    if (!this.props.encompass && prevProps.loading && !this.props.loading) {
      this.buildLog();
    }

    if (this.props.encompass && prevProps.room._id !== this.props.room._id) {
      this.setState({ ...INITIAL_STATE, loading: false }, () => {
        this.buildLog();
      });
    }

    if (this.props.encompass) {
      if (
        prevState.playing !== this.state.playing ||
        (!prevState.playing && this.state.changingIndex)
      ) {
        this.props.updateEnc(
          'VMT_UPDATE_REPLAYER',
          this.state,
          this.relativeDuration
        );
      }
    }

    if (this.state.stopTime && this.state.playing) {
      // if stopTime was set (encompass selection was clicked on)
      // check if replayer has reached end of selection
      if (this.state.timeElapsed >= this.state.stopTime) {
        // stop replayer and clear stopTime if done
        this.setState({ playing: false, stopTime: null });
      }
    }

    if (
      !prevState.playing &&
      this.state.playing &&
      this.state.logIndex < this.updatedLog.length
    ) {
      // switched from stopped to playing
      this.playing();
    } else if (!this.state.playing && this.interval) {
      // switched from playing to stopped
      clearInterval(this.interval);
    }
    if (
      this.props.changingIndex &&
      this.log[this.props.index].tab !==
        this.props.tabs[this.props.currentTab]._id
    ) {
      let tabStates = { ...this.state.tabState };
      tabStates[this.props.tabs[prevProps.currentTab]._id] = {
        construction: this.calculator.getState(),
        lastIndex: prevProps.index,
      };
      this.setState({ tabStates });
      // let startIndex;
      // if (tabStates[log[this.props.index].tab]) {
      //   startIndex = tabStates[log[this.props.index].tab].lastIndex;
      // }
      // else {startIndex = prevProps.index}
      let tabIndex;
      // find the target tab index
      this.props.tabs.forEach((tab, i) => {
        if (tab._id === this.props.log[this.props.index].tab) {
          tabIndex = i;
        }
      });
      // We've promisified changeTab() so we can ensure we wait for the state to be updated before proceeding
      this.props.changeTab(tabIndex);
    }
  }

  playing = () => {
    this.interval = setInterval(() => {
      let timeElapsed = this.state.timeElapsed;
      let logIndex = this.state.logIndex;
      let currentMembers = [...this.state.currentMembers];
      let startTime = this.state.startTime;
      let absTimeElapsed = this.state.absTimeElapsed;
      timeElapsed += PLAYBACK_FIDELITY * this.state.playbackSpeed;
      absTimeElapsed += PLAYBACK_FIDELITY * this.state.playbackSpeed;
      let nextEvent = this.updatedLog[this.state.logIndex + 1];
      let currentTab = this.state.currentTab;
      if (!nextEvent) {
        return this.setState({ playing: false });
      }
      if (timeElapsed >= nextEvent.relTime) {
        // WHAT IF ITS GREAT THAN THE NEXT...NEXT EVENT (THIS HAPPENS WHEN WE INCREASE THE PLAY SPEED) ???? NOT SURE HOW TO HANDLE
        if (nextEvent.tab) {
          this.props.room.tabs.forEach((tab, i) => {
            if (tab._id === nextEvent.tab) {
              currentTab = i;
            }
          });
        }
        logIndex++;
        if (nextEvent.autogenerated) {
          if (nextEvent.text.includes('joined')) {
            currentMembers.push({ user: nextEvent.user });
          } else if (nextEvent.text.includes('left')) {
            currentMembers = currentMembers.filter(u => {
              return u.user._id !== nextEvent.user._id;
            });
          }
        }
        if (this.updatedLog[this.state.logIndex].synthetic) {
          startTime = moment(nextEvent.timestamp).format(
            'MM/DD/YYYY h:mm:ss A'
          );
          absTimeElapsed = 0;
        }
      }
      this.setState(prevState => ({
        logIndex,
        timeElapsed,
        currentMembers,
        startTime,
        absTimeElapsed,
        changingIndex: false,
        currentTab,
      }));
    }, PLAYBACK_FIDELITY);
  };

  setTabLoaded = id => {
    this.tabsLoaded++;
    if (this.tabsLoaded === this.props.room.tabs.length) {
      this.setState({ allTabsLoaded: true });
    }
  };

  // Takes a % of total progress and goes to the nearest timestamp
  goToTime = (percent, doAutoPlay = false, stopTime = null) => {
    let logIndex;
    let timeElapsed = percent * this.relativeDuration;
    if (percent === 1) {
      // I.e. if 100% then go to the last event
      logIndex = this.updatedLog.length - 1;
      timeElapsed = this.relativeDuration;
    } else {
      this.updatedLog.some((entry, i) => {
        if (entry.relTime > timeElapsed) {
          logIndex = i === 0 ? 0 : i - 1;
          return true;
        }
        return false;
      });
    }
    let currentTab = this.state.currentTab;
    this.props.room.tabs.forEach((tab, i) => {
      if (tab._id === this.updatedLog[logIndex].tab) {
        currentTab = i;
      }
    });
    this.setState({
      timeElapsed,
      logIndex,
      currentTab,
      playing: doAutoPlay,
      stopTime,
      changingIndex: true,
    });
    // setTimeout(() => this.setState({playing:}))
  };

  pausePlay = () => {
    this.setState(prevState => ({
      playing: !prevState.playing,
    }));
  };

  reset = () => {
    this.setState({ changingIndex: false });
  };

  setCurrentMembers = currentMembers => {
    this.setState({ currentMembers });
  };

  setSpeed = speed => {
    this.setState({ playbackSpeed: speed });
  };

  changeTab = index => {
    return new Promise((resolve, reject) => {
      this.setState({ currentTab: index }, () => {
        resolve();
      });
    });
  };

  goBack = () => {
    this.props.history.goBack();
  };

  toggleFullscreen = () => {
    if (this.state.isFullscreen) {
      document.exitFullscreen().then(() => {
        // After exiting fullscreen resize ggb Graph
        this.setState({ isFullscreen: false });
      });
    } else {
      this.setState({
        isFullscreen: true,
      });
    }
  };

  onEncMessage = event => {
    let allowedOrigin = window.location.origin;

    let { origin, data } = event;

    if (allowedOrigin !== origin) {
      return;
    }

    let { messageType } = data;

    if (messageType === 'VMT_PAUSE_REPLAYER') {
      // pause replayer
      return this.setState({ playing: false });
    }

    if (messageType === 'VMT_GO_TO_TIME') {
      let { timeElapsed, doAutoPlay, stopTime } = data;

      if (typeof timeElapsed === 'number') {
        // is this the best way to set time?
        // or should we just set this.state.timeElapsed?
        let percentage = timeElapsed / this.relativeDuration;
        this.goToTime(percentage, doAutoPlay, stopTime);
      }
    }
  };

  render() {
    let replayer = (
      <ReplayerControls
        playing={this.state.playing}
        pausePlay={this.pausePlay}
        speed={this.state.playbackSpeed}
        setSpeed={this.setSpeed}
        index={this.state.logIndex}
        log={this.updatedLog}
        goToTime={this.goToTime}
        reset={this.reset}
        duration={this.relativeDuration || 0}
        settings={
          <Settings
            setSpeed={this.setSpeed}
            speed={this.state.playbackSpeed}
            settingsHidden={!this.state.showControls}
            isFullscreen={this.state.isFullscreen}
            toggleFullscreen={this.toggleFullscreen}
          />
        }
        slider={
          <Slider
            progress={(this.state.timeElapsed / this.relativeDuration) * 100}
            log={this.updatedLog}
            duration={this.relativeDuration || 0}
            playing={this.state.playing}
            goToTime={this.goToTime}
          />
        }
        clock={
          <Clock
            startTime={this.state.startTime}
            playing={this.state.playing}
            duration={this.relativeDuration || 0}
            relTime={this.state.timeElapsed}
            changingIndex={this.state.changingIndex}
            // absTimeElapsed={absTimeElapsed}
          />
        }
        // currentMembers={this.state.currentMembers}
        // setCurrentMembers={this.setCurrentMembers}
      />
    );

    let chat = (
      <ChatReplayer
        roomId={this.props.room._id}
        log={this.updatedLog}
        index={this.state.logIndex}
        changingIndex={this.state.changingIndex}
        reset={this.reset}
        setCurrentMembers={this.setCurrentMembers}
      />
    );
    let graphs = this.props.room.tabs.map((tab, i) => {
      if (tab.tabType === 'geogebra') {
        return (
          <GgbReplayer
            log={this.updatedLog}
            index={this.state.logIndex}
            changingIndex={this.state.changingIndex}
            playing={this.state.playing}
            reset={this.reset}
            changeTab={this.changeTab}
            currentTab={this.state.currentTab}
            setTabLoaded={this.setTabLoaded}
            tab={tab}
            tabId={i}
            isFullscreen={this.state.isFullscreen}
            inView={this.state.currentTab === i}
          />
        );
      } else {
        return (
          <DesmosReplayer
            log={this.updatedLog}
            index={this.state.logIndex}
            changingIndex={this.state.changingIndex}
            playing={this.state.playing}
            reset={this.reset}
            changeTab={this.changeTab}
            currentTab={this.state.currentTab}
            setTabLoaded={this.setTabLoaded}
            tab={tab}
            inView={this.state.currentTab === i}
          />
        );
      }
    });
    const { room, user } = this.props;
    const event = this.updatedLog[this.state.logIndex] || {};
    return (
      <Fragment>
        <WorkspaceLayout
          graphs={graphs}
          user={user}
          chat={this.updatedLog.length > 0 ? chat : null}
          tabs={
            <Tabs
              tabs={room.tabs}
              changeTabs={this.changeTab}
              currentTab={this.state.currentTab}
            />
          }
          currentMembers={
            this.state.currentMembers.length > 0 ? (
              <CurrentMembers
                currentMembers={this.state.currentMembers.map(
                  member => member.user
                )}
                members={room.members}
                expanded={true}
                activeMember={event.user}
              />
            ) : null
          }
          bottomLeft={replayer}
          activeMember={event.user}
          replayerControls={replayer}
          currentTab={this.state.currentTab}
          roomName={`${room.name} Replayer`}
          bottomRight={
            <Tools
              goBack={this.goBack}
              toggleControl={this.toggleControl}
              lastEvent={this.updatedLog[this.state.logIndex]}
              replayer
            />
          }
          replayer
          loaded={this.state.allTabsLoaded}
          isFullscreen={this.state.isFullscreen}
          membersExpanded
          chatExpanded
          instructionsExpanded
          encompass={this.props.encompass}
        />
        {!this.state.allTabsLoaded && this.updatedLog.length > 0 ? (
          <Loading message="Preparing the replayer..." />
        ) : null}
      </Fragment>
    );
  }
}

export default SharedReplayer;
